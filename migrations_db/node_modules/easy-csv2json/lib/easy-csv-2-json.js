"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EasyCSV2JSON = void 0;
const _1 = require(".");
class EasyCSV2JSON {
    constructor() {
        this.$table = [[]];
    }
    /**
     * Transform an CSV file to JSON object
     *
     * @static
     * @param {*} $input
     * @returns {Promise<any>}
     * @memberof EasyCSV2JSON
     */
    static async convert($input) {
        const eSCV = new EasyCSV2JSON();
        await eSCV.init($input);
        return eSCV.convert();
    }
    /**
     * Transform an CSV file to JSON object with metadata
     *
     * @param {EasyCSV2JSONInput} $input Input parameters containing the array buffer, charSep and headers indicator
     * @returns {Promise<[Array<Cell>]>} A table containing the data
     * @memberof EasyCSV2JSON
     */
    async init($input) {
        this.$options = $input;
        this.$table = [[]];
        const enc = new TextDecoder('utf-8');
        const arr = new Uint8Array($input.file);
        const csvContent = enc.decode(arr);
        if (csvContent) {
            let lines = csvContent.split('\r\n');
            if (lines.length === 1) {
                lines = csvContent.split('\n');
            }
            if (lines.length === 1) {
                lines = csvContent.split('\r');
            }
            let headers = [];
            let rowNumber = 0;
            for (const row in lines) {
                if (($input === null || $input === void 0 ? void 0 : $input.headers) && row === '0') {
                    headers = lines[row].split($input.charSep);
                    // check repeated headers
                    let headersTemp = [];
                    for (const index in headers) {
                        const count = headersTemp.filter((i) => i === headers[index])
                            .length;
                        headersTemp.push(headers[index]);
                        headers[index] += count > 0 ? count : '';
                    }
                }
                else {
                    this.$table[rowNumber] = new Array();
                    const columns = lines[row].split($input.charSep);
                    for (const cell in columns) {
                        if (columns[cell]) {
                            const newCell = await EasyCSV2JSON.inferType(columns[cell]);
                            newCell.headerName = headers[cell];
                            newCell.column = await EasyCSV2JSON.getColum(+cell);
                            newCell.row = rowNumber + 1;
                            this.$table[rowNumber].push(newCell);
                        }
                    }
                    rowNumber++;
                }
            }
        }
    }
    async convert() {
        var _a, _b;
        let result = [];
        for (const row in this.$table) {
            result[row] = ((_a = this.$options) === null || _a === void 0 ? void 0 : _a.headers) ? {} : [];
            for (const cell in this.$table[row]) {
                const _c = this.$table[row][cell], { headerName } = _c, currentCell = __rest(_c, ["headerName"]);
                if ((_b = this.$options) === null || _b === void 0 ? void 0 : _b.headers) {
                    result[row][headerName] = this.$options.metadata
                        ? currentCell
                        : currentCell.value;
                }
                else {
                    result[row].push(this.$options.metadata ? currentCell : currentCell.value);
                }
            }
        }
        return result;
    }
    async getTable() {
        return this.$table;
    }
    async val(cell) {
        var _a;
        return (_a = (await this.cell(cell))) === null || _a === void 0 ? void 0 : _a.value;
    }
    async setVal(cell, value) {
        var _a, _b;
        var column = (_a = cell.slice(0, cell.search(/\d/))) === null || _a === void 0 ? void 0 : _a.toUpperCase();
        var row = cell === null || cell === void 0 ? void 0 : cell.toUpperCase().replace(column, '');
        let result = (_b = this.$table[+row - 1]) === null || _b === void 0 ? void 0 : _b.find((i) => i.column === column);
        if (!result)
            throw new _1.OutOfRangeException(`Out of range '${cell}'`);
        result.value = value;
        return result;
    }
    async cell(cell) {
        var _a, _b;
        var column = (_a = cell.slice(0, cell.search(/\d/))) === null || _a === void 0 ? void 0 : _a.toUpperCase();
        var row = cell === null || cell === void 0 ? void 0 : cell.toUpperCase().replace(column, '');
        const result = (_b = this.$table[+row - 1]) === null || _b === void 0 ? void 0 : _b.find((i) => i.column === column);
        if (!result)
            throw new _1.OutOfRangeException(`Out of range '${cell}'`);
        return result;
    }
    async applyFormula(cell, fn) {
        const cellObject = (await this.cell(cell)).value;
        const newValue = await fn(cellObject, this);
        this.setVal(cell, newValue);
        return this.cell(cell);
    }
    async filterFn(column, fn, options = { newRowNumbers: true }) {
        let result = new EasyCSV2JSON();
        result.$options = this.$options;
        await result.emptyTable();
        let rowNumber = 1;
        for (const line of this.$table) {
            const coincidence = line.find((i) => i.column === column && fn(i.value));
            if (coincidence) {
                if (options.newRowNumbers) {
                    for (const cell of line) {
                        cell.row = rowNumber;
                    }
                }
                result.$table.push(line);
                rowNumber++;
            }
        }
        return result;
    }
    async filterVal(column, value, options = { newRowNumbers: true }) {
        return this.filterFn(column, (val) => val == value, options);
    }
    static async getColum(colNumber) {
        const columns = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
        let spin = 0;
        if (colNumber >= columns.length)
            spin = Math.floor(colNumber / columns.length);
        let result = `${columns[colNumber - columns.length * spin]}${spin > 0 ? await EasyCSV2JSON.getColum(spin - 1) : ''}`;
        return result;
    }
    async emptyTable() {
        this.$table = [[]];
        while (this.$table.length >= 1)
            this.$table.pop();
    }
    static async inferType(value) {
        const doit = (fn) => {
            try {
                return fn();
            }
            catch (ex) {
                return undefined;
            }
        };
        let result = +value;
        let typeName = '';
        if (!result) {
            result = doit(() => JSON.parse(value));
        }
        if (result === undefined) {
            if (!isNaN(Date.parse(value))) {
                result = new Date(value);
                typeName = 'date';
            }
        }
        if (result === undefined) {
            result = value;
        }
        if (!typeName) {
            typeName = typeof result;
        }
        return { value: result, type: typeName, column: '', row: 0 };
    }
}
exports.EasyCSV2JSON = EasyCSV2JSON;
